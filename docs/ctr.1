
.\" Manpage for ctr.
.TH man 1 "01 February 2016" "1.0" "CTR man page"
.SH NAME
ctr \- run a Citrine program
.SH SYNOPSIS
ctr [PROGRAM]
.SH DESCRIPTION
Citrine\*R is general purpose programming language for UNIX\*R-like operating systems.
.SH OPTIONS

.BR \-c " "[OUTNAME]
lexes and parses the program and writes a binary representation to disk under
the specified filename.

.BR \-i
displays information about a binary Citrine program

.BR \-r
runs a binary Citrine program.

.SH REFERENCE MANUAL
Citrine has 5 literals:
.RS 4
.br 
- Nil
.br
- Booleans (True, False)
.br
- Numbers (1, -2, 3.5)
.br
- Strings 'All Strings are UTF8!'
.br
- Code Blocks { parameters | code }
.br

.RE
The following messages are part of the Core API of the Citrine Programming Language:
.br
.BR.BR.BR

.B Nil
.nf
    
     Literal:
    
     Nil
.fi
.BR.BR.BR

.B [Nil] isNil
.nf
    
     Nil always answers this message with a boolean object 'True'.
.fi
.BR.BR.BR

.B Object
.nf
    
     This is the base object, the parent of all other objects.
     It contains essential object oriented programming features.
.fi
.BR.BR.BR

.B [Object] type
.nf
    
     Returns a string representation of the type of object.
.fi
.BR.BR.BR

.B [Object] equals: [other]
.nf
    
     Tests whether the current instance is the same as
     the argument.
    
     Alias: =
    
     Usage:
     object equals: other
.fi
.BR.BR.BR

.B [Object] myself
.nf
    
     Returns the object itself.
.fi
.BR.BR.BR

.B [Object] on: [String] do: [Block]
.nf
    
     Makes the object respond to a new kind of message.
     Use the semicolons to indicate the positions of the arguments to be
     passed.
    
     Usage:
    
     object on: 'greet' do: {\\ ... }.
     object on: 'between:and:' do: {\\ ... }.
    
.fi
.BR.BR.BR

.B [Object] respondTo: [String]
.nf
    
     Variations:
    
     [Object] respondTo: [String] and: [String]
     [Object] respondTo: [String] and: [String] and: [String]
    
     Default respond-to implemention, does nothing.
.fi
.BR.BR.BR

.B [Object] isNil
.nf
    
     Default isNil implementation.
    
     Always returns boolean object False.
.fi
.BR.BR.BR

.B Boolean
.nf
    
     Literal:
    
     True
     False
.fi
.BR.BR.BR

.B [Boolean] = [other]
.nf
    
     Tests whether the other object (as a boolean) has the
     same value (boolean state True or False) as the current one.
    
     Usage:
    
     (True = False) ifFalse: {\\ Pen write: 'This is not True!'. }.
.fi
.BR.BR.BR

.B [Boolean] != [other]
.nf
    
     Tests whether the other object (as a boolean) has the
     same value (boolean state True or False) as the current one.
    
     Usage:
    
     (True != False) ifTrue: {\\ Pen write: 'This is not True!'. }.
.fi
.BR.BR.BR

.B [Boolean] toString
.nf
    
     Simple cast function.
.fi
.BR.BR.BR

.B [Boolean] break
.nf
    
     Breaks out of the current block and bubbles up to the parent block if
     the value of the receiver equals boolean True.
    
     Usage:
    
     (iteration > 10) break. #breaks out of loop after 10 iterations
.fi
.BR.BR.BR

.B [Boolean] continue
.nf
    
     Skips the remainder of the current block in a loop, continues to the next
     iteration.
    
     Usage:
    
     (iteration > 10) continue.
.fi
.BR.BR.BR

.B [Boolean] ifTrue: [block]
.nf
    
     Executes a block of code if the value of the boolean
     object is True.
    
     Usage:
     (some expression) ifTrue: {\\ ... }.
    
.fi
.BR.BR.BR

.B [Boolean] ifFalse: [block]
.nf
    
     Executes a block of code if the value of the boolean
     object is True.
    
     Usage:
     (some expression) ifFalse: {\\ ... }.
    
.fi
.BR.BR.BR

.B [Boolean] not
.nf
    
     Returns the opposite of the current value.
    
     Usage:
     True := False not.
    
.fi
.BR.BR.BR

.B [Boolean] flip
.nf
    
     'Flips a coin'. Returns a random boolean value True or False.
    
     Usage:
     coinLandsOn := (Boolean flip).
.fi
.BR.BR.BR

.B [Boolean] either: [this] or: [that]
.nf
    
     Returns argument #1 if boolean value is True and argument #2 otherwise.
    
     Usage:
     Pen write: 'the coin lands on: ' + (Boolean flip either: 'head' or: 'tail').
.fi
.BR.BR.BR

.B [Boolean] and: [other]
.nf
    
     Returns True if both the object value is True and the
     argument is True as well.
    
     Usage:
    
     a && b
    
.fi
.BR.BR.BR

.B [Boolean] nor: [other]
.nf
    
     Returns True if the object value is False and the
     argument is False as well.
    
     Usage:
    
     a nor: b
    
.fi
.BR.BR.BR

.B [Boolean] or: [other]
.nf
    
     Returns True if either the object value is True or the
     argument is True or both are True.
    
     Usage:
    
     a || b
.fi
.BR.BR.BR

.B [Boolean] xor: [other]
.nf
    
     Returns True if either the object value is True or the
     argument is True but not both.
    
     Usage:
    
     a xor: b
.fi
.BR.BR.BR

.B [Boolean] toNumber
.nf
    
     Returns 0 if boolean is False and 1 otherwise.
.fi
.BR.BR.BR

.B Number
.nf
    
     Literal:
    
     0
     1
     -8
     2.5
    
     Represents a number object in Citrine.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Number] > [other]
.nf
    
     Returns True if the number is higher than other number.
.fi
.BR.BR.BR

.B [Number] >= [other]
.nf
    
     Returns True if the number is higher than or equal to other number.
.fi
.BR.BR.BR

.B [Number] < [other]
.nf
    
     Returns True if the number is less than other number.
.fi
.BR.BR.BR

.B [Number] <= [other]
.nf
    
     Returns True if the number is less than or equal to other number.
.fi
.BR.BR.BR

.B [Number] = [other]
.nf
    
     Returns True if the number equals the other number.
.fi
.BR.BR.BR

.B [Number] != [other]
.nf
    
     Returns True if the number does not equal the other number.
.fi
.BR.BR.BR

.B [Number] between: [low] and: [high]
.nf
    
     Returns True if the number instance has a value between the two
     specified values.
    
     Usage:
    
     q between: x and: y
.fi
.BR.BR.BR

.B [Number] odd
.nf
    
     Returns True if the number is odd and False otherwise.
.fi
.BR.BR.BR

.B [Number] even
.nf
    
     Returns True if the number is even and False otherwise.
.fi
.BR.BR.BR

.B [Number] + [Number]
.nf
    
     Adds the other number to the current one. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] inc: [Number]
.nf
    
     Increases the number ITSELF by the specified amount, this message will change the
     value of the number object itself instead of returning a new number.
.fi
.BR.BR.BR

.B [Number] - [Number]
.nf
    
     Subtracts the other number from the current one. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] dec: [number]
.nf
    
     Decreases the number ITSELF by the specified amount, this message will change the
     value of the number object itself instead of returning a new number.
.fi
.BR.BR.BR

.B [Number] * [Number or Block]
.nf
    
     Multiplies the number by the specified divider. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] times: [Block]
.nf
    
     Runs the block of code a 'Number' of times.
     This is the most basic form of a loop.
    
     Usage:
    
     7 times: { i | Pen write: i. }.
    
     The example above runs the block 7 times. The current iteration
     number is passed to the block as a parameter (i in this example).
.fi
.BR.BR.BR

.B [Number] multiplyBy: [Number]
.nf
    
     Multiplies the number ITSELF by multiplier, this message will change the
     value of the number object itself instead of returning a new number.
    
     Usage:
    
     x := 5.
     x multiplyBy: 2. #x is now 10.
    
     Use this message to apply the operation to the object itself instead
     of creating and returning a new object.
.fi
.BR.BR.BR

.B [Number] / [Number]
.nf
    
     Divides the number by the specified divider. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] divideBy: [Number]
.nf
    
     Divides the number ITSELF by divider, this message will change the
     value of the number object itself instead of returning a new number.
    
     Usage:
    
     x := 10.
     x divideBy: 2. #x will now be 5.
    
     Use this message to apply the operation to the object itself instead
     of generating a new object.
.fi
.BR.BR.BR

.B [Number] modulo: [modulo]
.nf
    
     Returns the modulo of the number. This message will return a new
     object representing the modulo of the recipient.
    
     Usage:
    
     x := 11 modulo: 3. #x will now be 2
    
     Use this message to apply the operation of division to the
     object itself instead of generating a new one.
.fi
.BR.BR.BR

.B [Number] toPowerOf: [power]
.nf
    
     Returns a new object representing the
     number to the specified power.
    
     Usage:
    
     x := 2 toPowerOf: 8. #x will be 256
    
     The example above will raise 2 to the power of 8 resulting in
     a new Number object: 256.
.fi
.BR.BR.BR

.B [Number] max: [other]
.nf
    
     Returns the biggest number of the two.
    
     Usage:
    
     x := 6 max: 4. #x is 6
     x := 6 max: 7. #x is 7
.fi
.BR.BR.BR

.B [Number] min: [other]
.nf
    
     Returns a the smallest number.
    
     Usage:
    
     x := 6 min: 4. #x is 4
     x := 6 min: 7. #x is 7
.fi
.BR.BR.BR

.B [Number] factorial
.nf
    
     Calculates the factorial of a number.
.fi
.BR.BR.BR

.B [Number] to: [number] by: [step] do: [block]
.nf
    
     Runs the specified block for each step it takes to go from
     the start value to the target value using the specified step size.
     This is basically how you write for-loops in Citrine.
    
     Usage:
    
     1 to: 5 by: 1 do: { step | Pen write: 'this is step #'+step. }.
.fi
.BR.BR.BR

.B [Number] floor
.nf
    
     Returns the next highest integer number by rounding down.
.fi
.BR.BR.BR

.B [Number] ceil
.nf
    
     Returns the next highest integer number by rounding up.
.fi
.BR.BR.BR

.B [Number] round
.nf
    
     Returns the rounded number.
.fi
.BR.BR.BR

.B [Number] abs
.nf
    
     Returns the absolute value of the number.
.fi
.BR.BR.BR

.B [Number] sqrt
.nf
    
     Returns the square root of the number.
.fi
.BR.BR.BR

.B [Number] exp
.nf
    
     Returns the exponent of the number.
.fi
.BR.BR.BR

.B [Number] sin
.nf
    
     Returns the sine of the number.
.fi
.BR.BR.BR

.B [Number] cos
.nf
    
     Returns the cosine of the number.
.fi
.BR.BR.BR

.B [Number] tan
.nf
    
     Caculates the tangent of a number.
.fi
.BR.BR.BR

.B [Number] atan
.nf
    
     Caculates the atan of a number.
.fi
.BR.BR.BR

.B [Number] log
.nf
    
     Calculates the logarithm of a number.
.fi
.BR.BR.BR

.B [Number] toString
.nf
    
     Wrapper for cast function.
.fi
.BR.BR.BR

.B [Number] toBoolean
.nf
    
     Casts a number to a boolean object.
.fi
.BR.BR.BR

.B String
.nf
    
     Literal:
    
     'Hello World, this is a String.'
    
     A sequence of characters. In Citrine, strings are UTF-8 aware.
     You may only use single quotes. To escape a character use the
     backslash '\\' character.
    
.fi
.BR.BR.BR

.BR.BR.BR

.B [String] bytes
.nf
    
     Returns the number of bytes in a string, as opposed to
     length which returns the number of UTF-8 code points (symbols or characters).
.fi
.BR.BR.BR

.B [String] = [other]
.nf
    
     Returns True if the other string is the same (in bytes).
.fi
.BR.BR.BR

.B [String] != [other]
.nf
    
     Returns True if the other string is not the same (in bytes).
.fi
.BR.BR.BR

.B [String] length
.nf
    
     Returns the length of the string in symbols.
     This message is UTF-8 unicode aware. A 4 byte character will be counted as ONE.
.fi
.BR.BR.BR

.B [String] + [other]
.nf
    
     Appends other string to self and returns the resulting
     string as a new object.
.fi
.BR.BR.BR

.B [String] append: [String].
.nf
    
     Appends the specified string to itself. This is different from the '+'
     message, the '+' message adds the specified string while creating a new string.
     Appends on the other hand modifies the original string.
    
     Usage:
    
     x := 'Hello '.
     x append: 'World'.
     Pen write: x. #Hello World
    
.fi
.BR.BR.BR

.B [String] from: [position] to: [destination]
.nf
    
     Returns a portion of a string defined by from-to values.
     This message is UTF-8 unicode aware.
    
     Usage:
    
     'hello' from: 2 to: 3. #ll
.fi
.BR.BR.BR

.B [String] from: [start] length: [length]
.nf
    
     Returns a portion of a string defined by from
     and length values.
     This message is UTF-8 unicode aware.
    
     Usage:
    
     'hello' from: 2 length: 3. #llo
.fi
.BR.BR.BR

.B [String] skip: [number]
.nf
    
     Returns a string without the first X characters.
.fi
.BR.BR.BR

.B [String] at: [position]
.nf
    
     Returns the character at the specified position (UTF8 aware).
    
     Usage:
    
     ('hello' at: 2). #l
.fi
.BR.BR.BR

.B [String] byteAt: [position]
.nf
    
     Returns the byte at the specified position (in bytes).
    
     Usage:
     ('abc' byteAt: 1). #98
.fi
.BR.BR.BR

.B [String] indexOf: [subject]
.nf
    
     Returns the index (character number, not the byte!) of the
     needle in the haystack.
    
     Usage:
    
     'find the needle' indexOf: 'needle'. #9
    
.fi
.BR.BR.BR

.B [String] up
.nf
    
     Returns a new uppercased version of the string.
     Note that this is just basic ASCII case functionality, this should only
     be used for internal keys and as a basic utility function. This function
     DOES NOT WORK WITH UTF8 characters !
.fi
.BR.BR.BR

.B [String] low
.nf
    
     Returns a new lowercased version of the string.
     Note that this is just basic ASCII case functionality, this should only
     be used for internal keys and as a basic utility function. This function
     DOES NOT WORK WITH UTF8 characters !
.fi
.BR.BR.BR

.B [String] lastIndexOf: [subject]
.nf
    
     Returns the index (character number, not the byte!) of the
     needle in the haystack.
    
     Usage:
    
     'find the needle' lastIndexOf: 'needle'. #9
.fi
.BR.BR.BR

.B [String] replace: [string] with: [other]
.nf
    
     Replaces needle with replacement in original string and returns
     the result as a new string object.
    
     Usage:
    
     'LiLo BootLoader' replace: 'L' with: 'l'. #lilo Bootloader
.fi
.BR.BR.BR

.B [String] trim
.nf
    
     Trims a string. Removes surrounding white space characters
     from string and returns the result as a new string object.
    
     Usage:
    
     ' hello ' trim. #hello
    
.fi
.BR.BR.BR

.B [String] ltrim
.nf
    
     Removes all the whitespace at the left side of the string.
.fi
.BR.BR.BR

.B [String] rtrim
.nf
    
     Removes all the whitespace at the right side of the string.
.fi
.BR.BR.BR

.B [String] toNumber
.nf
    
     Converts string to a number.
.fi
.BR.BR.BR

.B [String] toBoolean
.nf
    
     Converts string to boolean
.fi
.BR.BR.BR

.B StringSplit
.nf
    
     Converts a string to an array by splitting the string using
     the specified delimiter (also a string).
.fi
.BR.BR.BR

.B [String] htmlEscape
.nf
    
     Escapes HTML chars.
.fi
.BR.BR.BR

.B Block
.nf
    
     Literal:
    
     { parameters here... | code here... }
     {\\ code without parameters... }
    
     Examples:
    
     {\\ Pen write: 'a simple code block'. } run.
     { param | Pen write: param. } applyTo: 'write this!'.
     { a b | ^ a + b. } applyTo: 1 and: 2.
     { a b c | ^ a + b + c. } applyTo: 1 and: 2 and: 3.
    
.fi
.BR.BR.BR

.B [Block] applyTo: [object]
.nf
    
     Runs a block of code using the specified object as a parameter.
.fi
.BR.BR.BR

.B [Block] whileTrue: [block]
.nf
    
     Runs a block of code, depending on the outcome runs the other block
     as long as the result of the first one equals boolean True.
    
     Usage:
    
     x := 0.
     {\\ ^(x < 6). } whileFalse: {\\ x inc: 1. }. #increment x until it reaches 6.
    
     Here we increment variable x by one until it reaches 6.
     While the number x is lower than 6 we keep incrementing it.
     Don't forget to use the return ^ symbol in the first block.
.fi
.BR.BR.BR

.B [Block] whileFalse: [block]
.nf
    
     Runs a block of code, depending on the outcome runs the other block
     as long as the result of the first one equals to False.
    
     Usage:
    
     x := 0.
     {\\ ^(x > 5). } whileFalse: {\\ x inc: 1. }. #increment x until it reaches 6.
    
     Here we increment variable x by one until it reaches 6.
     While the number x is not higher than 5 we keep incrementing it.
     Don't forget to use the return ^ symbol in the first block.
.fi
.BR.BR.BR

.B [Block] run
.nf
    
     Sending the unary message 'run' to a block will cause it to execute.
     The run message takes no arguments, if you want to use the block as a function
     and send arguments, consider using the applyTo-family of messages instead.
     This message just simply runs the block of code without any arguments.
     
     Usage:
     
     {\\ Pen write: 'Hello World'. } run. #prints 'Hello World'
     
     The example above will run the code inside the block and display
     the greeting.
.fi
.BR.BR.BR

.B [Block] set: [name] value: [object]
.nf
    
     Sets a variable in a block of code. This how you can get closure-like
     functionality.
    
     Usage:
    
     shout := {\\ Pen write: (my message + '!!!'). }.
     shout set: 'message' value: 'hello'.
     shout run.
    
     Here we assign a block to a variable named 'shout'.
     We assign the string 'hello' to the variable 'message' inside the block.
     When we invoke the block 'shout' by sending the run message without any
     arguments it will display the string: 'hello!!!'.
    
     Similarly, you could use this technique to create a block that returns a
     block that applies a formula (for instance simple multiplication) and then set the
     multiplier to use in the formula. This way, you could create a block
     building 'formula blocks'. This is how you implement use closures
     in Citrine.
.fi
.BR.BR.BR

.B [Block] error: [object].
.nf
    
     Sets error flag on a block of code.
     This will throw an error / exception.
     You can attach an object to the error, for instance
     an error message.
    
     Example:
    
     {\\
       thisBlock error: 'oops!'.
     } catch: { errorMessage |
       Pen write: errorMessage.
     }, run.
.fi
.BR.BR.BR

.B [Block] catch: [otherBlock]
.nf
    
     Associates an error clause to a block.
     If an error (exception) occurs within the block this block will be
     executed.
    
     Example:
    
     #Raise error on division by zero.
     {\\
        var z := 4 / 0.
     } catch: { errorMessage |
        Pen write: e, brk.
     }, run.
.fi
.BR.BR.BR

.B [Array] new
.nf
    
     Creates a new Array.
    
     Usage:
    
     a := Array new.
     
     or, the short form:
     
     a := Array <- 1 ; 2 ; 3.
     
.fi
.BR.BR.BR

.B [Array] push: [Element]
.nf
    
     Pushes an element on top of the array.
    
     Usage:
    
     numbers := Array new.
     numbers push: 3.
.fi
.BR.BR.BR

.B [Array] map: [Block].
.nf
    
     Iterates over the array. Passing each element as a key-value pair to the
     specified block.
     
     Usage:
    
     files map: showName.
     files map: { key filename | Pen write: filename, brk. }.
.fi
.BR.BR.BR

.B [Array] each: [Block].
.nf
    
      Alias for [Array] map: [Block].
.fi
.BR.BR.BR

.B [Array] <- [Element1] ; [Element2] ; ...
.nf
    
     Creates a new instance of an array and initializes this
     array with a first element, useful for literal-like Array
     notations.
    
     Usage:
    
     a := Array <- 1 ; 2 ; 3.
    
     Note that the ; symbol here is an alias for 'push:'.
.fi
.BR.BR.BR

.B [Array] unshift: [Element].
.nf
    
     Unshift operation for array.
     Adds the specified element to the beginning of the array.
    
     Usage:
    
     a := Array new.
     a push: 1.
     a unshift: 3. #now contains: 3,1
.fi
.BR.BR.BR

.B [Array] join: [Glue].
.nf
    
     Joins the elements of an array together in a string
     separated by a specified glue string.
    
     Usage:
    
     collection := Array new.
     collection push: 1, push: 2, push 3.
     collection join: ','. # results in string: '1,2,3'
.fi
.BR.BR.BR

.B [Array] at: [Index]
.nf
    
     Returns the element in the array at the specified index.
     Note that the fisrt index of the array is index 0.
    
     Usage:
     
     fruits := Array <- 'apples' ; 'oranges' ; 'bananas'.
     fruits at: 1. #returns 'oranges'
.fi
.BR.BR.BR

.B [Array] @ [Index]
.nf
     
     Alias for [Array] at: [Index]
.fi
.BR.BR.BR

.B [Array] put: [Element] at: [Index]
.nf
    
     Puts a value in the array at the specified index.
     Array will be automatically expanded if the index is higher than
     the maximum index of the array.
     
     Usage:
     
     fruits := Array new.
     fruits put: 'apples' at: 5.
.fi
.BR.BR.BR

.B [Array] pop
.nf
    
     Pops off the last element of the array.
.fi
.BR.BR.BR

.B [Array] shift
.nf
    
     Shifts off the first element of the array.
.fi
.BR.BR.BR

.B [Array] count
.nf
    
     Returns the number of elements in the array.
.fi
.BR.BR.BR

.B [Array] from: [Begin] to: [End]
.nf
    
     Copies part of an array indicated by from and to and
     returns a new array consisting of a copy of this region.
.fi
.BR.BR.BR

.B [Array] + [Array]
.nf
    
     Returns a new array, containing elements of itself and the other
     array.
.fi
.BR.BR.BR

.BR.BR.BR

.B [Array] sort: [Block]
.nf
    
     Sorts the contents of an array using a sort block.
     Uses qsort.
.fi
.BR.BR.BR

.B Map
.nf
    
     Creates a Map object.
     
     Usage:
     
     files := Map new.
     files put: 'readme.txt' at: 'textfile'.
.fi
.BR.BR.BR

.B [Map] put: [Element] at: [Key]
.nf
    
     Puts a key-value pair in a map.
    
     Usage:
    
     map put: 'hello' at: 'world'.
    
.fi
.BR.BR.BR

.B [Map] at: [Key]
.nf
    
     Retrieves the value specified by the key from the map.
.fi
.BR.BR.BR

.B [Map] @ [Key]
.nf
     
     Alias for [Map] at: [Key].
     
.fi
.BR.BR.BR

.B [Map] count
.nf
    
     Returns the number of elements in the map.
.fi
.BR.BR.BR

.B [Map] each: [Block]
.nf
    
     Iterates over the map, passing key-value pairs to the specified block.
.fi
.BR.BR.BR

.B File
.nf
     
     Represents a File object.
     Creates a new file object based on the specified path.
     
     Usage:
     
     File new: '/example/path/to/file.txt'.
.fi
.BR.BR.BR

.B [File] path
.nf
    
     Returns the path of a file.
.fi
.BR.BR.BR

.B [File] read
.nf
    
     Reads contents of a file.
.fi
.BR.BR.BR

.B [File] write: [String]
.nf
    
     Writes content to a file.
.fi
.BR.BR.BR

.B [File] append: [String]
.nf
    
     Appends content to a file.
.fi
.BR.BR.BR

.B [File] exists
.nf
    
     Returns True if the file exists and False otherwise.
.fi
.BR.BR.BR

.B [File] include
.nf
    
     Includes the file as a piece of executable code.
.fi
.BR.BR.BR

.B [File] run
.nf
    
     Includes the file as a piece of executable code.
.fi
.BR.BR.BR

.B [File] delete
.nf
    
     Deletes the file.
.fi
.BR.BR.BR

.B [File] size
.nf
    
     Returns the size of the file.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Broom
.nf
     
     GarbageCollector, to invoke use:
     
     [Broom] sweep.
.fi
.BR.BR.BR

.B [Broom] dust
.nf
    
     Returns the number of objects collected.
.fi
.BR.BR.BR

.B GCCount
.nf
    
     Returns the number of objects marked.
.fi
.BR.BR.BR

.B [Shell] call: [String]
.nf
    
     Performs a Shell operation.
.fi
.BR.BR.BR

.B [Command] argument: [Number]
.nf
    
     Obtains an argument from the CLI invocation.
.fi
.BR.BR.BR

.B [Command] argCount
.nf
    
     Returns the number of CLI arguments passed to the script.
.fi
.BR.BR.BR

.B [Command] exit
.nf
     
     Exits program immediately.
.fi
.BR.BR.BR

.B [Command] env: [String]
.nf
    
     Returns the value of an environment variable.
    
     Usage:
    
     x := Command env: 'MY_PATH_VAR'.
.fi
.BR.BR.BR

.B [Command] env: [Key] val: [Value]
.nf
    
     Sets the value of an environment variable.
.fi
.BR.BR.BR

.B Command askQuestion
.nf
    
     Ask a question on the command-line, resumes program
     only after pressing the enter key.
     Only reads up to 100 characters.
    
     Usage:
    
     Pen write: 'What is your name ?'.
     x := Command askQuestion.
     Pen write: 'Hello ' + x + ' !', brk.
    
     The example above asks the user for his/her name and
     then displays the input received.
.fi
.BR.BR.BR

.B [Dice] rollWithSides: [Number]
.nf
    
     Rolls the dice, generates a pseudo random number.
.fi
.BR.BR.BR

.B [Dice] roll
.nf
    
     Rolls a standard dice with 6 sides.
.fi
.BR.BR.BR

.B [Clock] wait
.nf
    
     Waits X seconds.
.fi
.BR.BR.BR

.B [Clock] time
.nf
    
     Returns UNIX epoch time in seconds.
.fi
.BR.BR.BR

.B [Pen] write: [String]
.nf
    
     Writes string to console. 
.fi
.BR.BR.BR

.B [Pen] brk
.nf
     
     Outputs a newline character.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Request get: [string]
.nf
     
     Returns the value of the specified GET parameter from the HTTP query string.
     For example if the query string of an url is: ?search=glasses
     then the value of:
     
     item := Request get: 'search'.
     
     would be 'glasses'.
.fi
.BR.BR.BR

.B Request getArray: [string].
.nf
     
     Returns an array of strings extracted from the query string.
     For example if the query string contains: ?option=a&option=b
     
     Request getArray: 'option'.
     
     will contain two elements: 'a' and 'b'. Note that
     this also works with array-like notation: ?option[]='a'&option[]=b:
     
     Request getArray: 'option[]'.
     
     will return the same array.
.fi
.BR.BR.BR

.B Request post: [string].
.nf
     
     Obtains a string from the HTTP POST payload. Just like 'get:' but for
     POST variables. See 'Request get:' for details.
.fi
.BR.BR.BR

.B Request postArray: [string].
.nf
     
     Obtains an array from the HTTP POST payload. Just like 'getArray:' but for
     POST variables. See 'Request getArray:' for details.
.fi
.BR.BR.BR

.B Request cookie: [string].
.nf
     
     Obtains a string from the HTTP COOKIE payload. Just like 'get:' but for
     COOKIE variables. See 'Request get:' for details.
.fi
.BR.BR.BR

.B Request cookieArray: [string].
.nf
     
     Obtains an array from the HTTP COOKIE payload. Just like 'getArray:' but for
     COOKIE variables. See 'Request getArray:' for details.
.fi
.BR.BR.BR

.B Request file: [string].
.nf
     
     Returns array containing the path to the uploaded temporay file (0) and
     the desired name of the uploaded file (1).
.fi
.BR.BR.BR

.B Request serverOption: [string] is: [string].
.nf
     
     Sets a server option, available server option for SCGI server include:
     
     - minidle, minimum number of idle processes
     - maxidle, maximum number of idle processes
     - maxproc, maximum number of processes
     - maxreq,  maximum number of concurrent requests to allow
     
     Usage:
     
     Request
      serverOption: 'minidle' is: 8,
      serverOption: 'maxreq'  is: 100.
     
     This sets the minimum number of idle processes to 8 and the
     maximum number of concurrent requests to 100, you can chain
     multiple options using a comma (,).
.fi
.BR.BR.BR

.B Request host: [string] listen: [string] pid: [string] callback: [block].
.nf
    
     Sets up Storm Server.
     Storm Server is an SCGI server. Both the Request Object Plugin and Storm Server
     are based on S. Losen's CCGI library (http://libccgi.sourceforge.net/doc.html)
     licensed LGPL.
    
     To set up a Storm Server, specify host (i.e. 'localhost'),
     a port to listen to (i.e. 9000) a pid file '/var/run/mypid.pid' and a
     callback block.
    
     Usage:
    
     Request host:'localhost' listen:4000 pid:'/var/run/storm.pid' callback: {\\
      Pen write: 'Content-type: text/html\\n\\n'.
      var fname  := Command env: 'DOCUMENT_URI'.
      var script := File new: '/var/www/webapp'+fname.
      script include.
     }.
     
     Here we set up a server listening to port 4000. The callback prints out
     the content type header. Then, we extract the DOCUMENT URI, i.e. '/hello.ctr'
     and map this to a path '/var/www/webapp/hello.ctr'
     
     By default there is no output buffering, either create another callback or
     simply override the '<' or 'Pen' object to buffer instead of outputting
     directly.
.fi
.BR.BR.BR


.SH BUGS
This is a preliminary version (< 1.0) of Citrine, there might still be very serious bugs.
Please refrain from using this version in a production environment. This version of Citrine
is still considered 'alpha' stage and cannot be expected to be reliable.

.SH AUTHOR
Gabor de Mooij and the Citrine Community